<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<table>
    <tr>
        <th>Feature</th>
        <th>Java</th>
        <th>Kotlin</th>
    </tr>
    <tr>
        <td>Checked exceptions</td>
        <td style="color:green">Yes</td>
        <td style="color:red">No</td>
    </tr>
    <tr>
        <td>Primitive types</td>
        <td style="color:green">Yes</td>
        <td style="color:red">No</td>
    </tr>
    <tr>
        <td>Static members</td>
        <td style="color:green">Yes</td>
        <td style="color:red">No</td>
    </tr>
    <tr>
        <td>Package-private access level modifiers</td>
        <td style="color:green">Yes</td>
        <td style="color:red">No</td>
    </tr>
    <tr>
        <td>Big community</td>
        <td style="color:green">Yes</td>
        <td style="color:red">No</td>
    </tr>
    <tr>
        <td>Resources (Books, posts..)</td>
        <td style="color:green">Yes</td>
        <td style="color:red">No</td>
    </tr>
    <tr>
        <td>Functions with default and named parameters</td>
        <td style="color:red">No</td>
        <td style="color:green">Yes</td>
    </tr>
    <tr>
        <td>Extension functions</td>
        <td style="color:red">No</td>
        <td style="color:green">Yes</td>
    </tr>
    <tr>
        <td>Operator overloading</td>
        <td style="color:red">No</td>
        <td style="color:green">Yes</td>
    </tr>
    <tr>
        <td>Null-safety</td>
        <td style="color:red">No</td>
        <td style="color:green">Yes</td>
    </tr>
    <tr>
        <td>Primary constructors</td>
        <td style="color:red">No</td>
        <td style="color:green">Yes</td>
    </tr>
    <tr>
        <td>Singletons</td>
        <td style="color:red">No</td>
        <td style="color:green">Yes</td>
    </tr>
    <tr>
        <td>Range expressions</td>
        <td style="color:red">No</td>
        <td style="color:green">Yes</td>
    </tr>
    <tr>
        <td>Null-safety</td>
        <td style="color:red">No</td>
        <td style="color:green">Yes</td>
    </tr>
    <tr>
        <td>Smart casts</td>
        <td style="color:red">No</td>
        <td style="color:green">Yes</td>
    </tr>
    <tr>
        <td>String-handling functions</td>
        <td style="color:red">No</td>
        <td style="color:green">Yes</td>
    </tr>
    <tr>
        <td>Data classes</td>
        <td style="color:red">No</td>
        <td style="color:green">Yes</td>
    </tr>
    <tr>
        <td>Destructuring Declarations</td>
        <td style="color:red">No</td>
        <td style="color:green">Yes</td>
    </tr>
    <tr>
        <td>Statically typed language</td>
        <td style="color:green">Yes</td>
        <td style="color:green">Yes</td>
    </tr>


</table>

<h3>Things that are not in Kotlin that I don't miss from Java</h3>

Since I started using Kotlin, I've found that most of the time, you can use Kotlin to do anything you that you used to do with Java, but in a slightly different way.
I generally prefer Kotlin's way of doing things, but there are a couple of things I miss from Java.
However, Java is getting old so some of its features are only there because it is backward compatible.
In practice, what that means on the positive side is that you can still run a program done in Java 1 with Java 8, but the negative is that you still needs to include dated things like ";" at the end of each statement.

Here a few examples of features that you cannot find in Kotlin but which I personally don't miss anyway:
<ul>
    <li>Checked Exceptions: In my opinion checked exceptions are not useful, they make the code more verbose and less readable.
        This results in multiple throws clause declarations, and more generally they aren't compatible with functional coding.
    </li>
    <li>Primitive types: Kotlin has primitives too (similar to Java) but unlike Java, they are not a special case. In Kotlin,
        everything is an object, including basic types.
    </li>
    <li>Static members: Kotlin has replaced these with package-level (also known as top-level) functions and companion
        objects. The official Kotlin website recommends using package-level functions in most instances. These are functions declared outside of
        any class, so there is no need for an extra level of nesting.
    </li>
</ul>

<h3>Features that are available in Kotlin and should have been available in Java</h3>
<ul>
    <li>Functions with default and named parameters: In Kotlin you can define a function with default parameters. This
        way you can call a function and only have to specify the parameters that are different to the default ones:
    </li>
    [java]
    fun defaultSum(p1: Int, p2: Int = 10, p3: Int = 0): Int {
    return p1 + p2 + p3
    }

    assert(3 == defaultSum(1, 2))
    assert(13 == defaultSum(3))
    assert(15 == defaultSum(3, p3 = 2))

    [/java]
    <li>Extension functions: these are functions that can be called as a member of a class but are defined outside of it.
        This feature makes it easier to integrate with existing code. For instance, in Kotlin you can add a new
        function to the Java String class and use it in your code.
    </li>
    <li>Operator overloading: similar to other languages, Kotlin allows you to overload operators. For instance, you
        can define a special method plus to overload the + operator.
    </li>
    <li>Null-safety: in Kotlin, the compiler will be in charge of checking any possible NullPointerException.</li>
    <li>Smart casts: when you check if an object conforms to a given type, then the compiler already knows the type of
        the object. Therefore you don't need to cast it. Let's have a look to an example:
    </li>
        [code]
        if (x !is String){
            print(x.length) //there is no need to cast it
        }
        [/code]

    <li>Singletons: it is possible to build singletons with Java, but Kotlin provides first class support for creating
        singletons. You just need to use the word "object".
    </li>
    <li>Range expressions: Kotlin makes it easier to define a range by using the .. operator (ex: for (i in 1..4) ).
        Other keywords such as downTo (for reversing the order), step and until could also be very useful.
    </li>
    <li>Data classes: If you mark a class as "data", then the compiler automatically generates the following methods from all
        properties declared in the primary constructor: toString, equals, hashCode and copy.
    </li>
    <li>String-handling functions: Kotlin provides an extra number of functions and templates that makes it easier to
        work with Strings.
    </li>
    <li>Destructuring Declarations: this feature allows you to unpack a single composite value and use it to initialize
        several separate variables.
        For instance, you can 'destructure' an object and assign it to 2 variables: val (x,y) = Point(10, 20)
    </li>

</ul>

<h3>In summary</h3>
<p> In my opinion, although Kotlin doesn't have one single feature which will single-handedly blow your mind, when put altogether, the collection of new features that Kotlin offers really make a difference.
    Kotlin removes a lot of the boilerplate code that you have in Java and allows you to spend more time on the interesting parts of the code and less on routine matters.

    Kotlin is not just object-oriented but also functional too.
    A functional style provides extra conciseness, safer multi-threading and is easier to test.
    Most of the most popular features of functional languages are available in Kotlin, such as first-class functions and
    immutability.
    Although since Java 8 came out, Java also has had the functional style available, Kotlin provides syntactic and library support, meaning that you can use the functional style effortlessly.

    The fact that Kotlin is fully compatible with Java is also one of its biggest assets.
    Existing Java code can be called from Kotlin in a natural way, and Kotlin code can be used in Java too.
    This gives you the flexibility of mixing Java and Kotlin anywhere in your project. However, I personally wouldn't
    recommend mixing them, at least not in production code, because it can overcomplicate things. Nevertheless, you could introduce it for testing purposes.
    Currently, there are very good frameworks which offer a more expressive DSL for writing tests in Kotlin like KotlinTest and Spek.

    One field in which Java is definitely much better than Kotlin is in the quantity of available helpful resources.
    Java is more than 20 years old and therefore has an innumerable amount of books, articles, posts, etc written on the topic.
    Kotlin it is growing very fast, but still has a long way to go before it reaches the same size of community and resources as Java.

    In conclusion, Kotlin is a great language with lots of fantastic features that make coding much more pleasant and improves
    the quality and readability  of the code. Having said that, my advice is that if you are already working on a Java project, I wouldn't attempt to mix both languages within it.
    On the other hand, if you are planning to start a new project or a new microservice then I would definitely recommend using Kotlin from the very start.

</p>


</body>
</html>